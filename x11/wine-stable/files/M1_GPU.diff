From ae319caa3bf97b0ab688b1f44418dfd9d522f115 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Wed, 27 Jan 2021 11:16:46 -0800
Subject: [PATCH] winemac.drv: Use Metal to get a display's GPU info if
 possible.

Fixes an Apple Silicon issue where CGDisplayIOServicePort() returns
a fake AMD GPU "compatibility" node rather than the real GPU node.

Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winemac.drv/cocoa_display.m | 39 +++++++++++++++++++++++++++++---
 1 file changed, 36 insertions(+), 3 deletions(-)

diff --git dlls/winemac.drv/cocoa_display.m dlls/winemac.drv/cocoa_display.m
index e769772feaa..2e50b67c7d1 100644
--- dlls/winemac.drv/cocoa_display.m
+++ dlls/winemac.drv/cocoa_display.m
@@ -330,6 +330,27 @@ done:
     return ret;
 }
 
+/***********************************************************************
+ *              macdrv_get_gpu_info_from_display_id_using_metal
+ *
+ * Get GPU information for a CG display id using Metal.
+ *
+ * Returns non-zero value on failure.
+ */
+static int macdrv_get_gpu_info_from_display_id_using_metal(struct macdrv_gpu* gpu, CGDirectDisplayID display_id)
+{
+    id<MTLDevice> device;
+    int ret = -1;
+    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
+
+    device = [CGDirectDisplayCopyCurrentMetalDevice(display_id) autorelease];
+    if (device && [device respondsToSelector:@selector(registryID)])
+        ret = macdrv_get_gpu_info_from_registry_id(gpu, device.registryID);
+
+    [pool release];
+    return ret;
+}
+
 #else
 
 static int macdrv_get_gpus_from_metal(struct macdrv_gpu** new_gpus, int* count)
@@ -337,20 +358,32 @@ static int macdrv_get_gpus_from_metal(struct macdrv_gpu** new_gpus, int* count)
     return -1;
 }
 
+static int macdrv_get_gpu_info_from_display_id_using_metal(struct macdrv_gpu* gpu, CGDirectDisplayID display_id)
+{
+    return -1;
+}
+
 #endif
 
 /***********************************************************************
  *              macdrv_get_gpu_info_from_display_id
  *
  * Get GPU information from a display id.
- * This is a fallback for 32bit build or older Mac OS version where Metal is unavailable.
  *
  * Returns non-zero value on failure.
  */
 static int macdrv_get_gpu_info_from_display_id(struct macdrv_gpu* gpu, CGDirectDisplayID display_id)
 {
-    io_registry_entry_t entry = CGDisplayIOServicePort(display_id);
-    return macdrv_get_gpu_info_from_entry(gpu, entry);
+    int ret;
+    io_registry_entry_t entry;
+
+    ret = macdrv_get_gpu_info_from_display_id_using_metal(gpu, display_id);
+    if (ret)
+    {
+        entry = CGDisplayIOServicePort(display_id);
+        ret = macdrv_get_gpu_info_from_entry(gpu, entry);
+    }
+    return ret;
 }
 
 /***********************************************************************
-- 
2.20.1

From 5fbd40520d9a1505764b9e7b86f01d663b3aa391 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Wed, 27 Jan 2021 11:16:47 -0800
Subject: [PATCH] winemac.drv: Handle non-PCI GPUs correctly.

Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winemac.drv/cocoa_display.m | 22 +++++++++++++++-------
 1 file changed, 15 insertions(+), 7 deletions(-)

diff --git dlls/winemac.drv/cocoa_display.m dlls/winemac.drv/cocoa_display.m
index 2e50b67c7d1..7cc6f981fee 100644
--- dlls/winemac.drv/cocoa_display.m
+++ dlls/winemac.drv/cocoa_display.m
@@ -183,7 +183,9 @@ static int get_entry_property_string(io_registry_entry_t entry, CFStringRef prop
 /***********************************************************************
  *              macdrv_get_gpu_info_from_entry
  *
- * Starting from entry, search upwards to find the PCI GPU. And get GPU information from the PCI GPU entry.
+ * Starting from entry (which must be the GPU or a child below the GPU),
+ * search upwards to find the IOPCIDevice and get information from it.
+ * In case the GPU is not a PCI device, get properties from 'entry'.
  *
  * Returns non-zero value on failure.
  */
@@ -193,18 +195,21 @@ static int macdrv_get_gpu_info_from_entry(struct macdrv_gpu* gpu, io_registry_en
     io_registry_entry_t gpu_entry;
     kern_return_t result;
     int ret = -1;
-    char buffer[64];
     NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
 
     gpu_entry = entry;
-    while (![@"IOPCIDevice" isEqualToString:[(NSString*)IOObjectCopyClass(gpu_entry) autorelease]]
-           || get_entry_property_string(gpu_entry, CFSTR("IOName"), buffer, sizeof(buffer))
-           || strcmp(buffer, "display"))
+    while (![@"IOPCIDevice" isEqualToString:[(NSString*)IOObjectCopyClass(gpu_entry) autorelease]])
     {
         result = IORegistryEntryGetParentEntry(gpu_entry, kIOServicePlane, &parent_entry);
         if (gpu_entry != entry)
             IOObjectRelease(gpu_entry);
-        if (result != kIOReturnSuccess)
+        if (result == kIOReturnNoDevice)
+        {
+            /* If no IOPCIDevice node is found, get properties from the given entry. */
+            gpu_entry = entry;
+            break;
+        }
+        else if (result != kIOReturnSuccess)
         {
             [pool release];
             return ret;
@@ -404,6 +409,7 @@ static int macdrv_get_gpus_from_iokit(struct macdrv_gpu** new_gpus, int* count)
     int integrated_index = -1;
     int primary_index = 0;
     int gpu_count = 0;
+    char buffer[64];
     int ret = -1;
     int i;
 
@@ -417,7 +423,9 @@ static int macdrv_get_gpus_from_iokit(struct macdrv_gpu** new_gpus, int* count)
 
     while ((entry = IOIteratorNext(iterator)))
     {
-        if (!macdrv_get_gpu_info_from_entry(&gpus[gpu_count], entry))
+        if (!get_entry_property_string(entry, CFSTR("IOName"), buffer, sizeof(buffer)) &&
+            !strcmp(buffer, "display") &&
+            !macdrv_get_gpu_info_from_entry(&gpus[gpu_count], entry))
         {
             gpu_count++;
             assert(gpu_count < MAX_GPUS);

From 88220e0ee41640940e7686fe0cab7f1e0bfb42f1 Mon Sep 17 00:00:00 2001
From: Jan Sikorski <jsikorski@codeweavers.com>
Date: Mon, 18 Jan 2021 14:18:17 +0100
Subject: [PATCH] winemac.drv: Include depth32+stencil pixel formats in
 enumeration.

This is especially important for M1 GPUs as they don't support the 24/8 format.

Signed-off-by: Jan Sikorski <jsikorski@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winemac.drv/opengl.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git dlls/winemac.drv/opengl.c dlls/winemac.drv/opengl.c
index b66af0f1c47..9f02e93d376 100644
--- dlls/winemac.drv/opengl.c
+++ dlls/winemac.drv/opengl.c
@@ -741,7 +741,8 @@ static void enum_renderer_pixel_formats(renderer_properties renderer, CFMutableA
 
                         if (!(renderer.stencil_modes & depth_stencil_modes[stencil_mode].mode))
                             continue;
-                        if (accelerated && depth_stencil_modes[depth_mode].bits != 24 && stencil_mode > 0)
+                        if (accelerated && depth_stencil_modes[depth_mode].bits != 24 &&
+                            depth_stencil_modes[depth_mode].bits != 32 && stencil_mode > 0)
                             continue;
 
                         attribs[n++] = kCGLPFAStencilSize;
